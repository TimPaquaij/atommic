# coding=utf-8
# Generated by CodiumAI
from abc import ABC

import pytest
import torch

from atommic.collections.common.parts.transforms import Composer, Cropper, Masker, Normalizer, ZeroFillingPadding


class TestComposer:
    # Tests that a list of transforms is composed and applied to data.
    def test_compose_list_of_transforms(self):
        # Create a list of transforms
        transforms = [
            Cropper(cropping_size=(320, 320), spatial_dims=(-2, -1)),
            ZeroFillingPadding(zero_filling_size=(400, 400), spatial_dims=(-2, -1)),
        ]

        # Create an instance of the Composer class with the list of transforms
        composer = Composer(transforms)

        # Create dummy data
        data = torch.randn(1, 32, 360, 380, 2)

        # Apply the composed transforms to the data
        composed_data = composer(data)

        # Assert that the composed transforms were applied correctly
        assert composed_data.shape == (1, 32, 400, 400, 2)

    # Tests that a single transform is composed and applied to data.
    def test_compose_single_transform(self):
        # Create a single transform
        transforms = [
            Normalizer(normalization_type="max"),
        ]

        # Create an instance of the Composer class with the single transform
        composer = Composer(transforms)

        # Create dummy data
        data = torch.randn(1, 32, 360, 380, 2)

        # Apply the composed transforms to the data
        composed_data, attrs = composer(data)

        # Assert that the composed transforms were applied correctly
        assert composed_data.shape == (1, 32, 360, 380, 2)
        assert torch.max(torch.abs(composed_data)).item() <= 1.0
        assert torch.allclose(attrs["max"], torch.max(torch.abs(data)), rtol=0.5)

    # Tests that an empty list of transforms returns the data unchanged.
    def test_compose_empty_list_of_transforms(self):
        # Create an empty list of transforms
        transforms = []

        # Create an instance of the Composer class with the empty list of transforms
        composer = Composer(transforms)

        # Create dummy data
        data = torch.randn(2, 2, 2, 2, 2)

        # Apply the composed transforms to the data
        composed_data = composer(data)

        # Assert that the data remains unchanged
        assert torch.allclose(composed_data, data)

    # Tests that a list of transforms with None values returns the data unchanged.
    def test_compose_list_with_none_values(self):
        # Create a list of transforms
        transforms = [
            Cropper(cropping_size=(320, 320), spatial_dims=(-2, -1)),
            None,
            ZeroFillingPadding(zero_filling_size=(400, 400), spatial_dims=(-2, -1)),
        ]

        # Create an instance of the Composer class with the list of transforms
        composer = Composer(transforms)

        # Create dummy data
        data = torch.randn(1, 32, 360, 380, 2)

        # Apply the composed transforms to the data
        composed_data = composer(data)

        # Assert that the composed transforms were applied correctly
        assert composed_data.shape == (1, 32, 400, 400, 2)

    # Tests that a list of non-callable objects raises a TypeError.
    def test_compose_list_with_non_callable_objects(self):
        # Create a list of non-callable objects
        transforms = [ABC(), 123, "abc"]

        # Create an instance of the Composer class with the list of transforms
        composer = Composer(transforms)

        # Create dummy data
        data = torch.randn(2, 2, 2, 2, 2)

        # Assert that a TypeError is raised when applying the composed transforms to the data
        with pytest.raises(TypeError):
            composer(data)
