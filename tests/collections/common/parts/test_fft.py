# coding=utf-8

# Generated by CodiumAI

import pytest
import torch

from atommic.collections.common.parts.fft import fft2, fftshift, ifft2, ifftshift, roll, roll_one_dim


class TestFFT2:
    # Tests that the function works correctly with a random input tensor of shape (2, 3, 4, 5, 2)
    def test_fft2_random_input_tensor(self):
        input_tensor = torch.randn(2, 3, 4, 5, 2)
        output_tensor = fft2(input_tensor)
        assert output_tensor.shape == (2, 3, 4, 5, 2)

    # Tests that the function works correctly with centered=True and normalization="ortho"
    def test_fft2_centered_true_normalization_ortho(self):
        input_tensor = torch.randn(2, 3, 4, 5, 2)
        output_tensor = fft2(input_tensor, centered=True, normalization="ortho")
        assert output_tensor.shape == (2, 3, 4, 5, 2)

    # Tests that the function works correctly with spatial_dims=[-3, -2]
    def test_fft2_spatial_dims(self):
        input_tensor = torch.randn(2, 3, 4, 5, 2)
        output_tensor = fft2(input_tensor, spatial_dims=[-3, -2])
        assert output_tensor.shape == (2, 3, 4, 5, 2)


class TestIFFT2:
    # Tests that the function works correctly with a random input tensor of shape (2, 3, 4, 5, 2)
    def test_ifft2_random_input_tensor(self):
        input_tensor = torch.randn(2, 3, 4, 5, 2)
        output_tensor = ifft2(input_tensor)
        assert output_tensor.shape == (2, 3, 4, 5, 2)

    # Tests that the function works correctly with centered=True and normalization="ortho"
    def test_ifft2_centered_true_normalization_ortho(self):
        input_tensor = torch.randn(2, 3, 4, 5, 2)
        output_tensor = ifft2(input_tensor, centered=True, normalization="ortho")
        assert output_tensor.shape == (2, 3, 4, 5, 2)

    # Tests that the function works correctly with spatial_dims=[-3, -2]
    def test_ifft2_spatial_dims(self):
        input_tensor = torch.randn(2, 3, 4, 5, 2)
        output_tensor = ifft2(input_tensor, spatial_dims=[-3, -2])
        assert output_tensor.shape == (2, 3, 4, 5, 2)


class TestRollOneDim:
    # Tests that the function correctly rolls the tensor along the specified dimension by the specified shift amount
    def test_roll_one_dim(self):
        data = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        expected_output = torch.tensor([[7, 8, 9], [1, 2, 3], [4, 5, 6]])
        assert torch.allclose(roll_one_dim(data, 1, 0), expected_output)

    # Tests that the function returns the input tensor as is when the shift amount is 0
    def test_edge_case(self):
        data = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        assert torch.allclose(roll_one_dim(data, 0, 0), data)

    # Tests that the function correctly rolls the tensor along the specified dimension by the specified shift amount
    def test_other_case(self):
        data = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        expected_output = torch.tensor([[3, 1, 2], [6, 4, 5], [9, 7, 8]])
        assert torch.allclose(roll_one_dim(data, -2, 1), expected_output)


class TestRoll:
    # Tests that the function correctly rolls a tensor with shape (2, 3, 4, 5) by shift=[1, 2] and dim=[0, 1]
    def test_roll(self):
        data = torch.randn(2, 3, 4, 5)
        result = roll(data, [1, 2], [0, 1])
        assert result.shape == torch.Size([2, 3, 4, 5])

    # Tests that the function correctly handles a shift larger than the tensor size. Tensor shape is (2, 3, 4, 5),
    # shift=[6, 2], dim=[0, 1]
    def test_edge_case_1(self):
        data = torch.randn(2, 3, 4, 5)
        result = roll(data, [6, 2], [0, 1])
        assert result.shape == torch.Size([2, 3, 4, 5])

    # Tests that the function correctly handles different lengths of shift and dim. Tensor shape is (2, 3, 4, 5),
    # shift=[1, 2, 3], dim=[0, 1]
    def test_edge_case_2(self):
        data = torch.randn(2, 3, 4, 5)
        with pytest.raises(ValueError):
            roll(data, [1, 2, 3], [0, 1])

    # Tests that the function correctly rolls a tensor with shape (1, 1) by shift=[1] and dim=[0] (tensor with only
    # one element)
    def test_other_case_1(self):
        data = torch.randn(1, 1)
        result = roll(data, [1], [0])
        assert result.shape == torch.Size([1, 1])


class TestFFTShiftIFFTShift:
    # Tests that fftshift function works correctly with a random input tensor of shape (2, 3, 4, 5).
    def test_fftshift(self):
        data = torch.randn(2, 3, 4, 5)
        shifted_data = fftshift(data)
        assert shifted_data.shape == data.shape
        assert not torch.allclose(shifted_data[0, 0, 0, 0], data[0, 0, 0, 0])

    # Tests that ifftshift function works correctly with a random input tensor of shape (2, 3, 4, 5).
    def test_ifftshift(self):
        data = torch.randn(2, 3, 4, 5)
        shifted_data = ifftshift(data)
        assert shifted_data.shape == data.shape
        assert not torch.allclose(shifted_data[0, 0, 0, 0], data[0, 0, 0, 0])

    # Tests that fftshift function works correctly and unshifts the result.
    def test_fftshift_ifftshift(self):
        data = torch.randn(2, 3, 4, 5)
        shifted_data = fftshift(data)
        unshifted_data = ifftshift(shifted_data)
        assert unshifted_data.shape == data.shape
        assert torch.allclose(unshifted_data, data)

    # Tests that ifftshift function works correctly and unshifts the result.
    def test_ifftshift_fftshift(self):
        data = torch.randn(2, 3, 4, 5)
        shifted_data = ifftshift(data)
        unshifted_data = fftshift(shifted_data)
        assert unshifted_data.shape == data.shape
        assert torch.allclose(unshifted_data, data)
