# coding=utf-8

# Generated by CodiumAI

import pytest
import torch

from atommic.collections.common.losses.aggregator import AggregatorLoss
from atommic.core.neural_types.elements import LossType
from atommic.core.neural_types.neural_type import NeuralType


class TestAggregatorLoss:
    # Tests that the forward method returns the correct sum of losses when given valid inputs.
    def test_forward_method_returns_correct_sum_of_losses(self):
        # Create an instance of AggregatorLoss
        aggregator_loss = AggregatorLoss(num_inputs=3)

        # Create input losses
        loss1 = torch.tensor(2.0)
        loss2 = torch.tensor(3.0)
        loss3 = torch.tensor(4.0)

        # Call the forward method
        output_loss = aggregator_loss.forward(loss_1=loss1, loss_2=loss2, loss_3=loss3)

        # Check that the output loss is the correct sum of the input losses
        assert output_loss == torch.tensor(9.0)

    # Tests that an error is raised when the number of weights is not equal to the number of inputs.
    def test_error_raised_when_number_of_weights_not_equal_to_number_of_inputs(self):
        # Create an instance of AggregatorLoss with 3 inputs and 2 weights
        with pytest.raises(ValueError):
            aggregator_loss = AggregatorLoss(num_inputs=3, weights=[0.5, 0.5])

    # Tests that an error is raised when the input types are not correctly defined.
    def test_error_raised_when_input_types_not_correctly_defined(self):
        # Create an instance of AggregatorLoss with incorrect input types
        class IncorrectAggregatorLoss(AggregatorLoss):
            @property
            def input_types(self):
                return {"loss_1": NeuralType(elements_type=LossType())}

    # Tests that the forward method returns zero when all inputs are zero.
    def test_forward_method_returns_zero_when_all_inputs_are_zero(self):
        # Create an instance of AggregatorLoss
        aggregator_loss = AggregatorLoss(num_inputs=2)

        # Create input losses
        loss1 = torch.tensor(0.0)
        loss2 = torch.tensor(0.0)

        # Call the forward method
        output_loss = aggregator_loss.forward(loss_1=loss1, loss_2=loss2)

        # Check that the output loss is zero
        assert output_loss == torch.tensor(0.0)

    # Tests that the forward method returns the correct weighted sum of losses when given valid weights.
    def test_forward_method_returns_correct_weighted_sum_of_losses(self):
        # Create an instance of AggregatorLoss with 3 inputs and weights
        aggregator_loss = AggregatorLoss(num_inputs=3, weights=[0.5, 0.3, 0.2])

        # Create input losses
        loss1 = torch.tensor(2.0)
        loss2 = torch.tensor(3.0)
        loss3 = torch.tensor(4.0)

        # Call the forward method
        output_loss = aggregator_loss.forward(loss_1=loss1, loss_2=loss2, loss_3=loss3)

        # Check that the output loss is the weighted sum of the input losses
        assert output_loss == torch.tensor(2.7)
